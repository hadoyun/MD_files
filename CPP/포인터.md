# 포인터



그림을 그려라 

한번에 안된다

보고 또 봐야한다.

그리고 또 그려야한다.



```cpp
//char 1 

    
//short 2

//long 4

//long long 8

//int 4



//float 4

//double 8
```



```cpp
int a = 20;
```



## &의 용법

```cpp
&a -> (메모리 상에서의) a의 시작 주소 / a의 시작 번지
```

데이터를 처리를 하자 - > (== 프로그렘)



```cpp
#include <string>

string s{ "hello" };
	for (char& c : s)
	{
  		// 여기서 C 는 'h', 'e', 'l', 'l', 'o'가 된다. 
		// \n 문자 생략
		cout << c;
	}
```


### ○★○★○ C언어 에서는 메모리번지도 data이다!

메모리 번지수의 범위는 4byte 크기까지 나올 수 있다(0~42억 9천만)

이것은 unsinged int 와 같고 16진수(0~g까지)로 저장

```
// 0x123444 ... 
```



![](그림파일\메모리 상에서의 포인터.png)

```cpp
int a = 20;
int* p = &a; // p = 1000;
```







```cpp
int a = 20;

int* p = &a;

```

<strong>int*는 자료형 p는 변수명 &a 는 상수가 된다.</strong>



```cpp
// int a = 20;
// int* p = &a; 에 대한 해설

// a = 20

// &a = 100번지(가정)

// p = 100번지

// &p = 300번지

// *p = 20 (p가 100번인데 p가 가르키고 있는 값이 뭐냐? == p가 참조하는 값)
```

```cpp
int a{};

//원본 a를 바꾸는 방법 (포인터 사용)
{
	int* pa{ &a };
	*pa = 10;
}
//원본 a를 바꾸는 방법 (참조형 사용)
{
	int& ra{ a };
	ra = 10;
}
```









```cpp

S* - > S를 건드리고싶어서 받음

S** -> S*를 건드리고 싶어서 받음
```





### PP (포인터의 포인터)



이중 포인터는 포인터의 값을 바꾸기 위해 쓰인다. 

```cpp
ADDRINFOA* result{};

//const char* == PCSTR
//node 각각 연결되어있는 하나의 객체
//servicename == 특정 포트 네임 
//pp == 포인터 포인터 - 동적 할당을 한다는 의미이다. 
//이 함수를 거치면서 result 
getaddrinfo(buf, nullptr, &hint, &result);

//result 값은 남아있다.
freeaddrinfo(result);
```





```cpp
int main() {
	//물리적으로 null을 가리키는 da가 생긴다. 
	int* da{};

	//HEAP에 5를 가리키는 공간이 새로 생기고 da
	da = new int{ 5 };

	//heap 영역에 있는 동적 할당된 메모리가 7이 된다. 
	*da = 7;

	int* da_copy = da;

	//delete는 heap 영역에 있는 동적 할당된 메모리에 접근을 막는다.
	//delete da;

	//da_copy가 가르키는 heap 영역의 값은 접근이 불가능해지고, da는 댕글링포인터가 된다.
	delete da_copy;


	return 0;
}
```







```cpp
//==deletePP();
//포인터의 참조형을 사용한다면, 원본과 포인터 둘다 바꿀 수 있다.
void deleteRef(int*& ref)
{
	delete ref;
	ref = nullptr;
}

void deleteP(int* p)
{
	delete p;
}

void messPPP(int***ppp)
{
	*ppp = nullptr;
}

void cannotMessPPP(int** const* ppp)
{
	//컴파일 오류
	//*ppp = nullptr
}

//포인터를 바꾸고 싶을때 포인터의 포인터 **(pp)를 받는다.
void deletePP(int** pp)
{
	messPPP(&pp);

	//delete *pp;
	//*pp = nullptr;
}

int main() {
	//물리적으로 null을 가리키는 da가 생긴다. 
	int* da{};

	//HEAP에 5를 가리키는 공간이 새로 생기고 da
	da = new int{ 5 };

	//heap 영역에 있는 동적 할당된 메모리가 7이 된다. 
	*da = 7;

	{
		//int* da_copy = da;
		
		//delete는 heap 영역에 있는 동적 할당된 메모리에 접근을 막는다.
		//delete da;
		
		//da_copy가 가르키는 heap 영역의 값은 접근이 불가능해지고, da는 댕글링포인터가 된다.
		//delete da_copy;
	}

	{
		//함수의 인수는 복사된 값이 들어감으로 da는 댕글링포인터가 된다.
		
		//deleteP(da);
		//deletePP(&da);

		//delete da;
	}

	//(우리가 체감상) 원본에 접근 할 수 있다...!
	deleteRef(da);



	return 0;
}
```

// &변수 이름 == 주소!
	// 배열의 주소 == 배열의 이름
	// std::vector<int> a; a == vector a의 이름
	// 함수의 주소 == 함수의 이름 () 없이


```cpp
	bool success{ true };
	//const bool* const b{ &success };
	//오류! 
	const bool* b{ &success };
	//오류가 아님, - bool b의 값을 바꾸지 않겠다는 것임.
	b = nullptr;
```

```cpp
	const sockaddr_in& const jca = m_q_joining_client_addrs.front();
	//의미 없는 코드, 참조를 바꿀 수 없다.

```