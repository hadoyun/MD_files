# 개발 일지

## 2019. 09. 26.

### 마비노기 일일 쿠폰 계산기

** 되도록이면 하나의 반복문에서는 하나의 일만 하기!**

if (DOF == EDayOfWeek::일 || DOF == EDayOfWeek::토) 

반복문에서 날짜 초기화 까지 하려다가 영원히 일요일이 안오는 사태가 발생했음.

```cpp
#include <vector>
#include <iostream>

using namespace std;

enum class EDayOfWeek
{
	월,
	화,
	수,
	목,
	금,
	토,
	일
};


//마비노기 쿠폰 계산기!
// 
int Coupon(EDayOfWeek DOF, int days, int current_bonus)
{
	for (int i = 0; i < days; ++i)
	{
		current_bonus += 1;

		int id{ static_cast<int>(DOF) + 1 };
        
		if (id == 7) id = 0;

		DOF = static_cast<EDayOfWeek>(id);

		if (DOF == EDayOfWeek::일 || DOF == EDayOfWeek::토)
		{
			current_bonus += 1;
		}

	}

	return current_bonus;
}


int main()
{

	int z{};
	
	z = Coupon(EDayOfWeek::목, 14, 1);

	cout << z;

	return 0;
}
```

## 2019. 09. 27.

### cin으로 숫자 입력 받아 vector<>에 저장하기

cin으로 바로 vector에 입력받을 수 없으므로

`int input{};` 이라는 변수에 받은 후 `vector::emplace_back(input);` 한다.

```cpp
vector<int> v_cost{};

for (int i = 0; i < team_max; ++i)
{
    int input{};

    cin >> input;

    v_cost.emplace_back(input);
}
```



## 2019. 09. 28

### 알고리즘 문제 해결 방식,

- 한번에 하나씩 나누어서 생각하기



```cpp
using namespace std;

int get_sum(const vector<int> v_cost, int offset, int count)
{
	int sum{};
	for (int i = 0; i < count; ++i)
	{
		sum += v_cost[offset + i];
	}
	return sum;
}

void find_min_average(const vector<int>& v_cost, int team_max, int team_min)
{
	float min_average{ 3e+30f };
	for (int count = team_min; count < team_max + 1; ++count)
	{
		int min_sum{ 987'654'321 };
		for (int offset = 0; offset < team_max + 1 - count; ++offset)
		{
			min_sum = min(get_sum(v_cost, offset, count), min_sum);
		}
		min_average = min(min_average, (float)min_sum / count);
	}
	cout << min_average;
}
```

