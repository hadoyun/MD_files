# 알고리즘

## 재귀

### 재귀의 구조



```cpp
// call myelf ! 
void CallMyself(int n)
{
	if (n == 0) return;

	CallMyself(n - 1);

	cout << "나는 재귀(" << n << ")\n";
}

int main()
{
	CallMyself(5);

	return 0;
}

// result 
// 나는 재귀(1)
// 나는 재귀(2)
// 나는 재귀(3)
// 나는 재귀(4)
// 나는 재귀(5)

```




```cpp
// Depth 
// 실제 코드가 아님 - 
CallMyself(3);
{
	if (n == 0) return;

	CallMyself(2);
    {
        if (n == 0) return;

        CallMyself(1);
        {
            if (n == 0) return;

            CallMyself(0);
            {
                if (n == 0) return;

                // ... 실행 되지 않는다! (즉, 최고 깊이에 도달함)
            }
            
            cout << "나는 재귀(" << 1 << ")\n";
        }
        
        cout << "나는 재귀(" << 2 << ")\n";
    }
    
	cout << "나는 재귀(" << 3 << ")\n";
}

```

***범위 기반 for문 - ***








## vector의 사용

```cpp
vector<int> vec{};
int last{};

// 위험!!
vec.pop_back();
// vector의 size가 0이면 언더 플로우가 발생할 수 있다.

// 안전
if (vec.size()) vec.pop_back();


// 위험!!
last = vec.back();
// vector의 size가 0이면 back()은 vecotr의 마지막 값을 리턴해주는 함수 임으로 값을 불러 올 수 없다.

// 안전
last = (vec.size()) ? vec.back() : 0;
```





```cpp
using namespace std;

void combination(const vector<int>& list, int n, int offset, vector<int>& p_list)
{
	if (n == 0) return;

	for (int i = offset; i < (int)list.size(); ++i)
	{
		if (n > 1) p_list.emplace_back(list[i]);

        //재귀 함수를 할때는 자기 자신을 호출 할때 기저 사례를 찾을 수 있다.
		combination(list, n - 1, i + 1, p_list);
		//재귀 함수를 호출 할 때는 가장 깊은 곳에 있다고 가정한다.
        
		if (n == 1)
		{
			for (auto j : p_list)
			{
				cout << j;
			}

			cout << list[i] << endl;
		}
	}

	if (p_list.size()) p_list.pop_back();
}
```





```cpp
using namespace std;

void PermutationWithRepetition(const vector<int>& list, int depth, vector<int>& picked_list)
{
	if (depth == list.size()) return;

	for (int i = 0; i < list.size(); ++i)
	{
		if (depth < list.size() - 1) picked_list.emplace_back(list[i]);

		PermutationWithRepetition(list, depth + 1, picked_list);

		if (depth == 2)
		{
			for (auto j : picked_list)
			{
				cout << j;
			}

			cout << list[i] << endl;
		}
	}

	if (picked_list.size()) picked_list.pop_back();
}
```



```cpp
using namespace std;

void combination(const vector<int>& list, int n, vector<int>& p_list, int offset, vector<vector<int>>& result)
{
	if (n == 0) return;

	for (int i = offset; i < (int)list.size(); ++i)
	{
		if (n > 1) p_list.emplace_back(list[i]);

		combination(list, n - 1, p_list, i + 1, result);

		if (n == 1)
		{	
            //vector<int> v_row는 결과 값 한 줄이다.
			vector<int> v_row{};

			for (auto& j : p_list)
			{
				v_row.emplace_back(j);
			}
			
			v_row.emplace_back(list[i]);
			
           	//한 줄의 결과 값 v_row를 vector<vector<int>> result에 emplace_back()한다.
			result.emplace_back(v_row);
		}	
	}

	if (p_list.size()) p_list.pop_back();
}
```

