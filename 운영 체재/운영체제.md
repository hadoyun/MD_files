# 운영체제



## 운영체제의 개요



### 운영체제?

★운영체제 : 컴퓨터의 사용자와 하드웨어 사이에서 **'중개자'**역활을 하는 프로그램

운영체제의 역사

수작업 -> 단일 프로그래밍 -> 다중 프로그래밍 & 시분할 -> 모바일 os & 실시간 시스템



### 운영체제의 목적

1. 사용자가 컴퓨터를 편리하게 사용하는 것(사용자의 측면에서의 목적)
2. 컴퓨터 하드웨이거 효율적으로 사용되는 것(각각의 자원들을 효율적으로 사용)



### ★컴퓨터 시스템의 처리 구조

사용자 -> 어플리케이션 (소프트 웨어) -> 오퍼레이팅 시스템  - > 하드웨어





# 시스템의 발전

### 일괄처리 시스템(Batch System) 

개요 : 초기의 컴퓨터가 동작하는 방식으로서 물리적으로 콘솔에서 수행하던 방식에 사용하던 시스템이다.

초기의 운영체제는 즉시적으로 데이터를 처리할 수 있는 여건을 갖추지 못하였다.

그 대안으로 나온 것이 **일괄처리 시스템**으로 도입된 후 비슷한 것을 한꺼번에 묶어서 처리 할 수 있게 되었다.



그러나, 기계적인 입출력 장치의 속도가 CPU와 같은 장치의 속도보다 느리기 때문에 CPU가 계속 쉬는 상태인 idle 상태가 되는 경우가 많다.(상호작용이 되지 않았다.)



-> 따라서 일괄처리 시스템은 상호작용이 필요 없는 큰 단위의 작업들을 수행할 때 사용된다.





### 다중 프로그렘 시스템 (Multi Programmed System)

<strong>개요: 시피유가 수행할 작업을 항상 가져오도록하는 방식이다.</strong>

먼저 하드 디스크나 ssd에서 여러 개의 프로그램을 선택해서 메인 메모리에 적제한다.

그 후 메모리 내에 있는 작업 중에서 하나를 선택해 차례대로 실행한다.

이 때 수행 중인 작업이 입/출력 등의 문제 때문에 기다리는 상태에 도달하면 시피유는 다른 작업으로 넘어가서 수행을 계속한다.





### 시분할 시스템(time-sharing System)

개요 : 다중 프로그래밍의 단점을 채택해서 확장한 시스템, 프로그램이 수행되고 잇을때 아주 짧은 주기로 시피유 를 각각 프로그램에 할당을 해주는 방식이다.

시분할 시스템으로 사용자는 프로그램이 수행이 되고 있는 동안에서 상호작용(interact)를 할 수 있게 된다.





### 작업 스케쥴링

개요 : 보조기억장치(ssd 메모리)에 프로그램이 저장되어있고 그 중 일부를 선택해서 메모리를 적재하는 전략.



### cpu 스케쥴링 

메모리에 올라온 작업들 중에서 무엇부터 실행할지 고르는 전략





## 다양한 시스템들



### 다중 처리 시스템





### 레지스터

cpu의 단기기억 저장 장치

```cpp
RAX = 0000000000000001 RBX = 0000000000000000 RCX = 0000000000000001 RDX = 00000148C2ED6010 RSI = 0000000000000000 RDI = 0000000000000000
R8  = 00000148C2EDA3B0 R9  = 00007FFEF6C105B0 R10 = 0000000000000012 R11 = 00000148C2ED51E0 R12 = 0000000000000000 R13 = 0000000000000000 R14 = 0000000000000000 R15 = 0000000000000000 RIP = 00007FF7D37519A0 RSP = 00000024B1CFFC28 RBP = 0000000000000000 EFL = 00000204 
    // 8 byte 
```

E가 붙는 이유?

 확장된 이라는 뜻으로 

AX - 누산기 (계산결과과 저장됨, 리턴 값도 저장)

CX - 카운터 (for문등의 사용)

SI - source (복사할 원본 - 출발점)

DI - destination (도착지)



ip  - instruction pointer (메모리에 있는 주소 )



SP - stack pointer (스텍의 꼭대기 top)

BP - base pointer ( 스택의 바닥 base)



스텍이란? 매개변수와 지역변수가 저장되는 곳이다.



FL - flag (비트 단위 정보)



push 명령어 - 스택에 값을 추가할 때 쓰는 디스 어셈블리 명령어 

pop 명령어 - 스택에서 넣은 가장 마지막 값을 뺄 때 쓰는 명령어

mov 명령어 - 이동 후에 원래 있는 값을 안지운다 (== 복사) 즉, 복사 명령어

sub - sub a , b  a에서 b를 뺀다.

lea - stack의 맨 꼭대기 주소

rep - 반복



```
00007FF6246119CA  mov         dword ptr [a],0
```



add 

jmp - 





```cpp
int __cdecl foo(int a, char b)
{
	return 1;
}

int main()
{
    foo(2, 'a');
    
    return 0;
}
```

caller - 호출자  // 함수를 호출 하는자 (main)

 

callee - 피호출자 // 호출을 받은자 (foo)



```cpp
CreateWindow();
```

callee 가 스택을 정리 하기 때문에, 함수가 컴파일 될 때부터 스택을 얼마나 정리할 지 알고 있어야함.

(__stdecl)







```cpp
#include <iostream>
#include <Windows.h>

int __cdecl foo(int a, char b)
{
	return 1;
}

struct S
{
	int x{};

	S operator+(const S& b)
	{
		S r{};

		r.x = x + b.x;

		return r;
	}
};

int main()
{
	S sa{}, sb{};

	S sc{ sa + sb };

	int a{};

	foo(2, 'a');

	

	return 0;
}
```

